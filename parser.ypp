%{
// C user declarations
#include <iostream>
#include <string>
#include "hw3_output.hpp"
#include "tokens.hpp"
#include "stypes.hpp"

#define GET_SYM(x) symbolTable.getVarSymbol(STYPE2STD(string, x))
#define GET_SYMTYPE(x) symbolTable.getVarSymbol(STYPE2STD(string, x))->getType()

#define GET_FUNC(x) symbolTable.getFuncSymbol(STYPE2STD(string, x))
#define GET_FUNCTYPE(x) symbolTable.getFuncSymbol(STYPE2STD(string, x))->getType()


namespace yy {
using namespace output;
using namespace hw3;
using namespace std;
}
using namespace output;
using namespace hw3;
using namespace std;

hw3::SymbolTable symbolTable;

%}

%code requires {
   #include "stypes.hpp"
}

/* %define api.prefix {hw3} */

/* %union {
    std::shared_ptr<hw3::ExpC> exp;
    std::shared_ptr<hw3::VarTypeNameC> varTypeName;
    std::shared_ptr<hw3::RetTypeNameC> retType;
    std::shared_ptr<std::vector<std::string> > idList;
    std::shared_ptr<std::vector<std::string> > typeList;
    std::shared_ptr<hw3::IdC> id;
    std::shared_ptr<hw3::StringC> idName;
} */

/* Declarations */
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc AUTO
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF

%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMENT
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%nonassoc COMMA
%right ELSE
%right ASSIGN
%left OR
%left AND
%left EQOP
%left RELOP
%left PLUSOP
%left MULTOP
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%%
/* Rules */
Program:        Funcs                               {
                                                    auto mainFunc = GET_FUNC("main");
                                                    if (mainFunc->getType() != "void" or mainFunc->getArgTypes().size() != 0) {
                                                        errorMainMissing();
                                                    }
                                                    symbolTable.removeScope();
                                                    }
                ;
Funcs:          /* Epsilon */                       {}
                | FuncDecl Funcs                    {};
FuncDecl:       RetType ID LPAREN Formals           {
                                                    shared_ptr<FuncIdC> funcId(NEW(FuncIdC, (STYPE2STD(string, $2), DC(RetTypeNameC, $1)->getTypeName(), VECS($4))));
                                                    symbolTable.addSymbol(STYPE2STD(string, $2), funcId);
                                                    }
                    RPAREN LBRACE
                                                    {
                                                    symbolTable.addScope();
                                                    symbolTable.retType = DC(RetTypeNameC, $1);
                                                    }
                    Statements RBRACE
                                                    {
                                                    symbolTable.removeScope();
                                                    symbolTable.retType = nullptr;
                                                    }
;
RetType:        Type                                {$$ = $1;}
                | VOID                              {$$ = NEW(RetTypeNameC, ("VOID"));}
                ;
Formals:        /* Epsilon */                       {$$ = NEWSTD(vector<string>);}
                | FormalsList                       {$$ = $1;}
;
FormalsList:    FormalDecl                          {
                                                    auto vec = vector<string>();
                                                    vec.push_back(DC(IdC, $1)->getType());
                                                    $$ = NEWSTD_V(vector<string>, (vec));}
                | FormalDecl COMMA FormalsList      {
                                                    VECS($3).push_back(DC(IdC, $1)->getType());
                                                    $$ = $3;
                                                    }
                ;
FormalDecl:     TypeDecl                            {$$ = $1;}
                ;
Statements:     Statement                           {}
                | Statements Statement              {}
                ;
Statement:      LBRACE {symbolTable.addScope();} Statements RBRACE {symbolTable.removeScope();}
                | TypeDecl SC                       {}
                | TypeDecl ASSIGN Exp SC            {
                                                    if (DC(IdC, $1)->getType() != DC(ExpC, $3)->getType()) {
                                                        errorMismatch(yylineno);
                                                    }
                                                    }
                | AUTO ID ASSIGN Exp SC             {symbolTable.addSymbol(STYPE2STD(string, $2), NEW(IdC,(STYPE2STD(string, $2), DC(ExpC, $4)->getType())));}
                | ID ASSIGN Exp SC                  {
                                                        if (GET_SYMTYPE($1) != DC(ExpC,$3)->getType()) {
                                                            errorMismatch(yylineno);
                                                        }
                                                    }
                | Call SC                           {}
                | RETURN SC                         {
                                                        if (symbolTable.retType == nullptr) {
                                                            throw "This should be impossible. Syntax error wise";
                                                        } else if (symbolTable.retType->getTypeName() != "VOID") {
                                                            errorMismatch(yylineno);
                                                        }
                                                    }
                | RETURN Exp SC                     {
                                                        if (symbolTable.retType == nullptr) {
                                                            throw "This should be impossible. Syntax error wise";
                                                        } else if (symbolTable.retType->getTypeName() != DC(ExpC, $2)->getType()) {
                                                            errorMismatch(yylineno);
                                                        }
                                                    }
                | IF LPAREN Exp RPAREN Statement  %prec IF  {}
                | IF LPAREN Exp RPAREN Statement ELSE Statement {}
                | WHILE LPAREN Exp RPAREN {symbolTable.nestedLoopDepth++;} Statement {symbolTable.nestedLoopDepth--;}
                | BREAK SC                          {
                                                        if (symbolTable.nestedLoopDepth == 0) {
                                                            errorUnexpectedBreak(yylineno);
                                                        }
                                                    }
                | CONTINUE SC                       {
                                                        if (symbolTable.nestedLoopDepth == 0) {
                                                            errorUnexpectedContinue(yylineno);
                                                        }
                                                    }
                ;
TypeDecl:       Type ID                             {
                                                    auto symbol = NEW(IdC, (STYPE2STD(string, $2), DC(VarTypeNameC, $1)->getTypeName()));
                                                    symbolTable.addSymbol(STYPE2STD(string, $2), symbol);
                                                    $$ = symbol;
                                                    }
                ;
Call:           ID LPAREN ExpList RPAREN            {
                                                    auto funcId = GET_FUNC($1);
                                                    if (funcId->getArgTypes().size() != STYPE2STD(vector<string>, $3).size()) {
                                                        errorPrototypeMismatch(yylineno, funcId->getName(), funcId->getArgTypes());
                                                    } else {
                                                        for (int i = 0; i < STYPE2STD(vector<string>, $3).size(); i++) {
                                                            if (funcId->getArgTypes()[i] != STYPE2STD(vector<string>, $3)[i]) {
                                                                errorPrototypeMismatch(yylineno, funcId->getName(), funcId->getArgTypes());
                                                            }
                                                        }
                                                        $$ = NEW(RetTypeNameC, (funcId->getType()));
                                                    }
                                                    }
                | ID LPAREN RPAREN                  {
                                                    auto funcId = GET_FUNC($1);
                                                    if (funcId->getArgTypes().size() != 0) {
                                                        errorPrototypeMismatch(yylineno, funcId->getName(), funcId->getArgTypes());
                                                    } else {
                                                        $$ = NEW(RetTypeNameC, (funcId->getType()));
                                                    }
                                                    }
                ;
ExpList:        Exp                                 {$$ = NEWSTD(vector<string>);
                                                    VECS($$).push_back(DC(ExpC, $1)->getType());}
                | Exp COMMA ExpList                 {VECS($3).push_back(DC(ExpC, $1)->getType());
                                                    $$ = $3;}
                ;
Type:           INT                                 {$$ = NEW(VarTypeNameC, ("INT"));}
                | BYTE                              {$$ = NEW(VarTypeNameC, ("BYTE"));}
                | BOOL                              {$$ = NEW(VarTypeNameC, ("BOOL"));}
                ;
Exp:            LPAREN Exp RPAREN                   {$$ = $2;}
                | Exp PLUSOP Exp                    { if (not (DC(ExpC, $1)->isInt() or DC(ExpC, $1)->isByte()) and not (DC(ExpC, $3)->isInt() or DC(ExpC, $3)->isByte())) {
                                                        errorMismatch(yylineno);
                                                    } else if (DC(ExpC, $1)->isInt() or DC(ExpC, $3)->isInt()) {
                                                        $$ = NEW(ExpC,("INT"));
                                                    } else /* Both are bytes */ {
                                                        $$ = NEW(ExpC,("BYTE"));
                                                    }}
                | Exp MULTOP Exp                    { if (not (DC(ExpC, $1)->isInt() or DC(ExpC, $1)->isByte()) and not (DC(ExpC, $3)->isInt() or DC(ExpC, $3)->isByte())) {
                                                        errorMismatch(yylineno);
                                                    } else if (DC(ExpC, $1)->isInt() or DC(ExpC, $3)->isInt()) {
                                                        $$ = NEW(ExpC,("INT"));
                                                    } else /* Both are bytes */ {
                                                        $$ = NEW(ExpC,("BYTE"));
                                                    }}
                | ID                                {$$ = NEW(ExpC,(GET_SYMTYPE($1)));}
                | Call                              {$$ = NEW(ExpC,(DC(ExpC, $1)->getType()));}
                | NUM                               {$$ = NEW(ExpC,("INT"));}
                | NUM B                             {$$ = NEW(ExpC,("BYTE")); /* TODO: Check upto 256 */}
                | STRING                            {$$ = NEW(ExpC,("STRING"));}
                | TRUE                              {$$ = NEW(ExpC,("BOOL"));}
                | FALSE                             {$$ = NEW(ExpC,("BOOL"));}
                | NOT Exp                           {if (not DC(ExpC, $2)->isBool()) {errorMismatch(yylineno);} $$ = NEW(ExpC, ("BOOL"));}
                | Exp AND Exp                       {if (not DC(ExpC, $1)->isBool() or not DC(ExpC, $3)->isBool()) {errorMismatch(yylineno);} $$ = NEW(ExpC,("BOOL"));}
                | Exp OR Exp                        {if (not DC(ExpC, $1)->isBool() or not DC(ExpC, $3)->isBool()) {errorMismatch(yylineno);} $$ = NEW(ExpC,("BOOL"));}
                | Exp RELOP Exp                     {if (not DC(ExpC, $1)->isInt() or not DC(ExpC, $3)->isInt()) {errorMismatch(yylineno);} $$ = NEW(ExpC,("BOOL"));}
                | Exp EQOP Exp                      {if (not DC(ExpC, $1)->isInt() or not DC(ExpC, $3)->isInt()) {errorMismatch(yylineno);} $$ = NEW(ExpC,("BOOL"));}
                | LPAREN Type RPAREN Exp            { /* TODO: Which casts are allowed */ }
                ;
%%


/* User routines */
int main() {
    yyparse();
    return 0;
}
