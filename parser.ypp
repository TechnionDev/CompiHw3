%{
// C user declarations
#include <iostream>
#include <string>
#include "output.hpp"
#include "tokens.hpp"

using std::cout;
using std::endl;
using std::cin;
using std::cerr;
using namespace output;

%}
/* Declarations */
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc AUTO
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF

%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMENT
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%nonassoc COMMA
%right ELSE
%right ASSIGN
%left OR
%left AND
%left EQOP
%left RELOP
%left PLUSOP
%left MULTOP
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%%
/* Rules */
Program:        Funcs                               {output::printProductionRule(1);};
Funcs:          /* Epsilon */                       {output::printProductionRule(2);}
                | FuncDecl Funcs                    {output::printProductionRule(3);};
FuncDecl:       RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {output::printProductionRule(4);}
;
RetType:        Type                                {output::printProductionRule(5);}
                | VOID                              {output::printProductionRule(6);}
                ;
Formals:        /* Epsilon */                       {output::printProductionRule(7);}
                | FormalsList                       {output::printProductionRule(8);}
;
FormalsList:    FormalDecl                          {output::printProductionRule(9);}
                | FormalDecl COMMA FormalsList      {output::printProductionRule(10);}
                ;
FormalDecl:     Type ID                             {output::printProductionRule(11);}
;
Statements:     Statement                           {output::printProductionRule(12);}
                | Statements Statement              {output::printProductionRule(13);}
                ;
Statement:      LBRACE Statements RBRACE            {output::printProductionRule(14);}
                | Type ID SC                        {output::printProductionRule(15);}
                | Type ID ASSIGN Exp SC             {output::printProductionRule(16);}
                | AUTO ID ASSIGN Exp SC             {output::printProductionRule(17);}
                | ID ASSIGN Exp SC                  {output::printProductionRule(18);}
                | Call SC                           {output::printProductionRule(19);}
                | RETURN SC                         {output::printProductionRule(20);}
                | RETURN Exp SC                     {output::printProductionRule(21);}
                | IF LPAREN Exp RPAREN Statement  %prec IF  {output::printProductionRule(22);}
                | IF LPAREN Exp RPAREN Statement ELSE Statement {output::printProductionRule(23);}
                | WHILE LPAREN Exp RPAREN Statement {output::printProductionRule(24);}
                | BREAK SC                          {output::printProductionRule(25);}
                | CONTINUE SC                       {output::printProductionRule(26);}
                ;
Call:           ID LPAREN ExpList RPAREN            {output::printProductionRule(27);}
                | ID LPAREN RPAREN                  {output::printProductionRule(28);}
                ;
ExpList:        Exp                                 {output::printProductionRule(29);}
                | Exp COMMA ExpList                 {output::printProductionRule(30);}
                ;
Type:           INT                                 {$$ = new VarTypeNameC("INT");}
                | BYTE                              {$$ = new VarTypeNameC("BYTE");}
                | BOOL                              {$$ = new VarTypeNameC("BOOL");}
                ;
Exp:            LPAREN Exp RPAREN                   {output::printProductionRule(34);}
                | Exp PLUSOP Exp                    {output::printProductionRule(35);}
                | Exp MULTOP Exp                    {output::printProductionRule(35);}
                | ID                                {$$ = $1}
                | Call                              {output::printProductionRule(37);}
                | NUM                               {$$ = $1;}
                | NUM B                             {$$ = ((IntC *) $1)->toByteC();}
                | STRING                            {$$ = $1;}
                | TRUE                              {output::printProductionRule(41);}
                | FALSE                             {output::printProductionRule(42);}
                | NOT Exp                           {output::printProductionRule(43);}
                | Exp AND Exp                       {output::printProductionRule(44);}
                | Exp OR Exp                        {output::printProductionRule(45);}
                | Exp RELOP Exp                     {output::printProductionRule(46);}
                | Exp EQOP Exp                      {output::printProductionRule(46);}
                | LPAREN Type RPAREN Exp            {output::printProductionRule(47);}
                ;
%%

/* User routines */
int main() {
    yyparse();
    return 0;
}
