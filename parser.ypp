%{
// C user declarations
#include <iostream>
#include <string>
#include "output.hpp"
#include "tokens.hpp"

using std::cout;
using std::endl;
using std::cin;
using std::cerr;
using namespace output;

SymbolTable symbolTable;

%}
%union {
    ExpC *exp;
    VarTypeNameC *varTypeName;
    RetTypeNameC *retType;
    vector<string> *idList;
    IdC *id;
}

/* Declarations */
%nonassoc VOID
%nonassoc <exp> INT
%nonassoc <exp> BYTE
%nonassoc B
%nonassoc <exp> BOOL
%nonassoc AUTO
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF

%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMENT
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%nonassoc COMMA
%right ELSE
%right ASSIGN
%left OR
%left AND
%left EQOP
%left RELOP
%left PLUSOP
%left MULTOP
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%type <exp> Exp
%type <varTypeName> Type;
%type <retType> RetType;
%type <idList> Formals;
%type <id> FormalDecl;
%type <id> TypeDecl;
%type <idList> FormalsList;

%%
/* Rules */
Program:        Funcs                               {output::printProductionRule(1);};
Funcs:          /* Epsilon */                       {}
                | FuncDecl Funcs                    {};
FuncDecl:       RetType ID LPAREN Formals           {FuncIdC *funcId = new FuncIdC($2->getTypeName(), $1, $4);
                                                    symbolTable.addFunc($2, funcId);}
                                    RPAREN LBRACE 
                                                    {symbolTable.addScope();} 
                                    Statements RBRACE 
                                                    {symbolTable.popScope();}
;
RetType:        Type                                {$$ = $1;}
                | VOID                              {$$ = new RetTypeNameC("VOID");}
                ;
Formals:        /* Epsilon */                       {$$ = new vector<string>();}
                | FormalsList                       {$$ = $1;}
;
FormalsList:    FormalDecl                          {auto vec = new vector<string>();
                                                    vec->push_back($1->getType());
                                                    $$ = vec;}
                | FormalDecl COMMA FormalsList      {$3->push_back($1->getType());
                                                    $$ = $3;}
                ;
FormalDecl:     TypeDecl                            {$$ = $1;}
                ;
Statements:     Statement                           {}
                | Statements Statement              {}
                ;
Statement:      LBRACE {symbolTable.addScope();} Statements RBRACE {symbolTable.popScope();}
                | TypeDecl SC                       {}
                | TypeDecl ASSIGN Exp SC            {}
                | AUTO ID ASSIGN Exp SC             {symbolTable.addSymbol($2, new IdC($2, $4->getType()));}
                | ID ASSIGN Exp SC                  {}
                | Call SC                           {}
                | RETURN SC                         {}
                | RETURN Exp SC                     {}
                | IF LPAREN Exp RPAREN Statement  %prec IF  {}
                | IF LPAREN Exp RPAREN Statement ELSE Statement {}
                | WHILE LPAREN Exp RPAREN Statement {}
                | BREAK SC                          {}
                | CONTINUE SC                       {}
                ;
TypeDecl:       Type ID                             {IdC *symbol = new IdC($2, $1.getTypeName());
                                                    symbolTable.addSymbol($2, symbol);
                                                    $$ = symbol;}
                ;
Call:           ID LPAREN ExpList RPAREN            {}
                | ID LPAREN RPAREN                  {$$ = symbolTable.getSymbol($1);}
                ;
ExpList:        Exp                                 {}
                | Exp COMMA ExpList                 {}
                ;
Type:           INT                                 {$$ = new VarTypeNameC("INT");}
                | BYTE                              {$$ = new VarTypeNameC("BYTE");}
                | BOOL                              {$$ = new VarTypeNameC("BOOL");}
                ;
Exp:            LPAREN Exp RPAREN                   {$$ = $2;}
                | Exp PLUSOP Exp                    { if (not ($1->isInt() or $1->isByte()) and not ($3->isInt() or $3->isByte())) {
                                                        errorMismatch(yylineno);
                                                    } else if ($1->isInt() or $3->isInt()) {
                                                        $$ = new ExpC("INT");
                                                    } else /* Both are bytes */ {
                                                        $$ = new ExpC("BYTE");
                                                    }}
                | Exp MULTOP Exp                    { if (not ($1->isInt() or $1->isByte()) and not ($3->isInt() or $3->isByte())) {
                                                        errorMismatch(yylineno);
                                                    } else if ($1->isInt() or $3->isInt()) {
                                                        $$ = new ExpC("INT");
                                                    } else /* Both are bytes */ {
                                                        $$ = new ExpC("BYTE");
                                                    }}
                | ID                                {$$ = symbolTable.getSymbol($1); /* IdC inherits from ExpC */}
                | Call                              {$$ = new ExpC($1->getType());}
                | NUM                               {$$ = new ExpC("INT");}
                | NUM B                             {$$ = new ExpC("BYTE");}
                | STRING                            {$$ = new ExpC("STRING");}
                | TRUE                              {$$ = new ExpC("BOOL");}
                | FALSE                             {$$ = new ExpC("BOOL");}
                | NOT Exp                           {if (not $2->isBool()) {errorMismatch(yylineno);} $$ = new ExpC("BOOL");}
                | Exp AND Exp                       {if (not $1->isBool() or not $3->isBool()) {errorMismatch(yylineno);} $$ = new ExpC("BOOL");}
                | Exp OR Exp                        {if (not $1->isBool() or not $3->isBool()) {errorMismatch(yylineno);} $$ = new ExpC("BOOL");}
                | Exp RELOP Exp                     {if (not $1->isInt() or not $3->isInt()) {errorMismatch(yylineno);} $$ = new ExpC("BOOL");}
                | Exp EQOP Exp                      {if (not $1->isInt() or not $3->isInt()) {errorMismatch(yylineno);} $$ = new ExpC("BOOL");}
                | LPAREN Type RPAREN Exp            {output::printProductionRule(47);}
                ;
%%


/* User routines */
int main() {
    yyparse();
    return 0;
}
